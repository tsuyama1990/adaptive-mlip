ご提示いただいた「PYACEMAKER 次世代アーキテクチャ要求定義書 (PRD) Version: 2.1.0」を拝見しました。非常に野心的かつ、HPC環境での長期間MDシミュレーションにおける物理的・システム的なボトルネック（連続性の欠如、熱ノイズへの過敏反応、切り出し時の物理的破綻、計算量爆発など）を的確に解消する、極めて論理的で優れたアーキテクチャだと感じます。特にFLAREの教訓を活かした「Master-Slave逆転」と「物理的修復を伴う局所切り出し」の組み合わせは強力ですね。

このPRDに基づくシステムの品質と実用性を担保するため、研究者（ユーザー）視点での**受入テスト（UAT: User Acceptance Testing）シナリオ**を策定しました。各Phaseのパラダイムシフトが正しく機能しているかを検証する構成にしています。

---

# PYACEMAKER v2.1.0 受入テスト（UAT）及びチュートリアル計画 (Master Plan)

このドキュメントは、PYACEMAKER Version 2.1.0の機能要件（ALL_SPEC.md）及びシステムアーキテクチャ設計（SYSTEM_ARCHITECTURE.md）に基づく、ユーザー受入テスト（UAT）および新規ユーザー向けチュートリアルのマスタープランを定義します。

## 1. チュートリアル戦略 (Tutorial Strategy)

開発された各サイクル（CYCLE01〜04）の複雑な機能をユーザーが直感的に検証・理解できるよう、**単一のMarimoノートブック (`tutorials/UAT_AND_TUTORIAL.py`)** を作成し、すべてのUATシナリオを統合します。

*   **Marimoの採用:** インタラクティブな実行、コードの自己文書化、およびステートの確実な管理が可能な `marimo` を採用します。これにより、ユーザーはセル単位でアーキテクチャの挙動を確認できます。
*   **実行モード (Real vs. Mock):**
    *   **Mock Mode (CI/Tutorial用):** デフォルトのモードです。重いDFT計算（QE）や長時間の学習（Pacemaker）、推論（MACE）を高速なダミークラス（例: Lennard-Jonesポテンシャル、乱数ジェネレーター）でモック化し、数秒でパイプライン全体のロジック（切り出し、状態管理、再開）を検証できるようにします。
    *   **Real Mode (本番検証用):** 設定フラグ（例: `USE_REAL_ENGINES=True`）を切り替えることで、実際にQEやMACEを呼び出す本番環境テストモードに切り替わる設計とします。

## 2. チュートリアル計画 (Tutorial Plan)

以下の内容を包含する単一ファイル `tutorials/UAT_AND_TUTORIAL.py` を実装します。

### セクション構成案

1.  **はじめに (Introduction):** PYACEMAKER v2.1.0の「階層的蒸留アーキテクチャ」の概要図（Mermaid）と、本チュートリアルの目的（Mockモードでの動作確認）を説明。
2.  **シナリオ 1: Zero-Shot Distillation (Phase 1):**
    *   4元系合金の `DistillationConfig` を定義。
    *   `MACEManager` (Mock) を用いて、不確実性ベースのフィルタリングが動作し、DFTなしで `base.yace` (ダミー) が生成されることを実演。
3.  **シナリオ 2: Intelligent Cutout (Phase 3):**
    *   巨大なバルク構造（ASE `bulk` で生成）に意図的に欠陥を導入。
    *   `extract_intelligent_cluster` 関数を呼び出し、`force_weight` の割り当て（Core/Buffer）と自動終端処理（H原子付与）を可視化（ASEのplot機能などを利用してインライン表示）。
4.  **シナリオ 3: Seamless Resume (Phase 4 / Engine):**
    *   LAMMPSエンジン（Mock）を起動し、途中で意図的にHalt例外を発生させる。
    *   `restart_file` を用いて、例外発生ステップから正確に速度・座標が引き継がれて再開（Resume）されることをログ出力で証明。
5.  **シナリオ 4: Orchestrator & Resilience:**
    *   `Orchestrator` のメインループを数サイクル回す。
    *   `StateManager` によって `state.json` が生成されていること、および `cleanup_artifacts` によって巨大なダミーファイルが削除されていることをファイルシステムの確認を通じて実演。

## 3. チュートリアル検証 (Tutorial Validation)

このチュートリアルファイル自体が、システムのCI（継続的インテグレーション）における結合テストとして機能します。

*   **自動テスト:** `pytest` のテストスイートから `marimo export html tutorials/UAT_AND_TUTORIAL.py` 相当のコマンドを実行（またはAPI経由で実行）し、エラーなく完走することをもって、全機能のインテグレーションが成功しているとみなします。

---

## 補足: 個別機能の受入テストシナリオ (Detailed Scenarios)

以下は、各開発サイクルで定義されたUATの詳細シナリオです（上記チュートリアル内でコードとして実装されます）。

## シナリオ1：Phase 1 - ゼロショット蒸留とベースライン構築の検証

**目的:** DFTを一切呼び出さず、MACEの推論のみで物理的に妥当な初期ポテンシャル（LJ Delta Learning適用）が構築されることを確認する。

* **前提条件:**
* 入力元素として4元系（例: Fe, Pt, Mg, O）が指定されている。
* `DistillationConfig` が有効（`enable: True`）になっている。


* **操作手順:**
1. 初期化スクリプトを実行し、Phase 1を起動する。
2. ログおよび出力ディレクトリを監視する。


* **期待される結果（合格基準）:**
* 自動的に単体・二元系のサブシステム構造プール（ランダム、歪み、欠陥入り等）が生成されること。
* DIRECTサンプリングにより、構造数が指定のサンプリング数（例: 1000）に絞り込まれること。
* MACEによる推論が行われ、不確実性が `uncertainty_threshold` を下回る構造のみが抽出されること。
* **DFT（QE）が一度も呼び出されずに**、LJポテンシャルをベースラインとした `base.yace` が生成されること。



## シナリオ2：Phase 2 - 物理バリデーションと自動再学習の検証

**目的:** 構築されたポテンシャルが物理的安定性の基準を満たさない場合、自動でサンプリング密度を上げて自己修復（再学習）ループを回すか確認する。

* **前提条件:**
* Phase 1で生成された `base.yace` が存在する。
* わざと精度が低くなるよう、Phase 1のサンプリング数を極端に減らした状態のポテンシャルを用意する。


* **操作手順:**
1. Validatorを起動し、Phase 2を実行する。


* **期待される結果（合格基準）:**
* 安定相の弾性定数、フォノン分散、EOSが計算されること。
* 意図的に低精度にしたポテンシャルにおいて、フォノン分散に虚数振動（不安定性）が検出された際、**自動的にPhase 1のサンプリング密度（または範囲）が拡張され、再学習がトリガーされる**こと。
* ミニチュアMDによるストレステストが完走、またはHaltした場合にUncertainty Map（不確実性の温度依存性プロファイル）が出力されること。



## シナリオ3：Phase 3 - 熱ノイズの排除とインテリジェント・クラスター抽出

**目的:** 新アーキテクチャの核心である「二段階閾値」によるノイズ耐性と、ダングリングボンドを排除したクリーンな切り出しを検証する。

* **前提条件:**
* 本番環境規模（数万原子）のMDをセットアップする。
* `ActiveLearningThresholds` と `CutoutConfig` が適切に設定されている。


* **操作手順:**
1. MDをスタートさせる。
2. 熱ノイズを模倣するため、1〜2ステップだけ単一原子の不確実性を `threshold_call_dft` 以上に跳ね上がらせる（擬似的にデータを操作、または高温設定にする）。
3. その後、未知の界面や欠陥構造を系に衝突・導入させ、持続的な不確実性上昇を発生させる。


* **期待される結果（合格基準）:**
* **熱ノイズ耐性:** 手順2の瞬間的なスパイクではMDがHaltせず、継続すること（`smooth_steps` の機能証明）。
* **震源地特定:** 手順3で持続的なスパイクが起きた際、初めてHaltし、`threshold_add_train` を超えた原子群のみが「震源地」として特定されること。
* **物理的修復切り出し:**
* Core（`force_weight=1.0`）とBuffer（`force_weight=0.0`）が正しく切り出されていること。
* **Core原子が固定（Freeze）された状態で、MACEによってBuffer領域のみが事前緩和（Relax）されること。**
* 表面の切断手に対して自動終端処理（H原子などのダミー付与）が行われ、クラスターが電気的に中性化されていること。


* **DFTの確実な収束:** 抽出されたクラスターのDFT計算（SCFループ）が発散することなく、正常にGround Truth Forceを取得して完了すること。



## シナリオ4：Phase 4 - 階層的ファインチューニングとシームレス再開

**目的:** 破滅的忘却を防ぐインクリメンタル更新と、MDが初期化されずに「巻き戻しなし」で再開できるかを検証する。

* **前提条件:**
* シナリオ3を通過し、少数のクリーンなDFTデータが取得されている状態。


* **操作手順:**
1. Phase 4の学習プロセスからMD再開までのフローを監視する。
2. 再開直後のMDのエネルギー変化（ログ）を確認する。


* **期待される結果（合格基準）:**
* 取得したDFTデータを用いてMACEがファインチューニングされること。
* 覚醒MACEにより数千のサロゲートデータが瞬時に生成されること。
* **破滅的忘却の防止:** 過去のデータ（リプレイバッファ）とサロゲートデータを用いて、バッチ再学習ではなく**差分学習（Delta Learning）**が実行され、学習が短時間（O(1)の計算量）で完了すること。
* **連続性の担保:** ポテンシャル更新後、MDが「Step 0」からではなく、**Haltした直後のステップ番号・座標・速度を引き継いで再開**すること（Master-Slave逆転の証明）。
* **ソフトスタート:** 再開直後の数ステップでLangevin熱浴等のソフトスタートが機能し、エネルギーの非連続的な爆発（系が吹っ飛ぶ現象）が起きないこと。



## シナリオ5：HPC環境での堅牢性（非機能要件）ストレステスト

**目的:** ジョブの強制終了やプロセスダウンに対する耐性と、アーティファクトの自動クリーンアップを検証する。

* **前提条件:**
* 実際のHPC環境（Slurm等）、または並列実行をエミュレートできる環境。


* **操作手順:**
1. MDループ、またはサロゲート生成タスクの実行中に、意図的にPythonメインプロセスを `kill -9` で強制終了させる（Wall-time切れの模倣）。
2. 再度、同じディレクトリでジョブを投入（レジューム）する。
3. 裏で巨大な `.wfc` ファイル（波動関数ファイル）が生成されるのを監視する。


* **期待される結果（合格基準）:**
* **ステート復旧:** 再投入時、最初からやり直すのではなく、SQLite/JSONの細粒度チェックポイントから直前の状態（特定のサロゲート生成の途中、またはDFT計算完了直後など）から数秒〜数分以内で復帰すること。
* **自動クリーンアップ:** 学習と推論が成功し不要になった `.wfc` ファイルや巨大なダンプファイルが、デーモンプロセスによって自動的に削除または圧縮され、ストレージ容量を圧迫しないこと。



---

### テスト実施に向けた推奨事項

* **モック（Mock）の活用:** シナリオ3や4を毎回フルにDFTを回してテストすると時間がかかりすぎるため、QE_Driverが常に固定のダミーForceを返す「モックDFTモード」を開発用実装に組み込んでおくことを強くお勧めします。これにより、インフラやパイプラインの結合テストを数分で回せるようになります。
* **可視化による確認:** クラスター切り出しと事前緩和（Phase 3）の妥当性は、数字だけでは直感的に分かりづらいため、抽出前・抽出後・緩和後・終端処理後の構造を`.xyz`ファイル等で出力し、OVITOなどのビジュアライザーで目視確認するステップを最初の数回は必ず設けてください。

このPRDのスコープは非常に高度ですが、このテストをクリアできれば、間違いなく世界トップクラスの大規模材料シミュレーション基盤になるはずです。テストシナリオの粒度の調整や、特定のモジュールについての深掘りが必要であれば、いつでもお知らせください。